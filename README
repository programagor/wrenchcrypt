wrenchcrypt -- Deniable Encryption for humans
Inspired by MaruTukku

The main idea behind this program is that encrypted data and random noise can't be distinguished without additional knowledge. Thus, if encrypted data is randomly interlayed with random data, it can't be determined whether a considered block contains meaningful data or not.

This program operates on files called "Extent", which have the following layout:

+------------------------------+ --------------\
|           HEADERS            |               |
| * block size in bytes        |               |
| * total size in blocks (m)   |               |
| * number of aspects    (n)   |               |
| * used cipher                |               |
+------------------------------+               |
+------------------------------+ --\           |
|           ASPECT_0           |   |           |
| * KEY_0 (password protected) |   |           |
| * GEN_0 (encrypted by KEY_0) |   |           |
| * MAP_0 (encrypted by KEY_0) |   |           |
|    * Address of A_0/B_0      |   |           |
|    * Address of A_0/B_1      |   |           |
|    * ...                     |   |           |
|    * Address of A_0/B_m      |   |           |
+------------------------------+   |           |
|           ASPECT_1           |   |           |
| * KEY_1 (password protected) |   |           |
| * GEN_1 (encrypted by KEY_1) |   |           |
| * MAP_1 (encrypted by KEY_1) |   |           |
|    * Address of A_1/B_0      |   |           |
|    * Address of A_1/B_1      |   +-> Aspects |
|    * ...                     |   |           +-> Extent
|    * Address of A_1/B_m      |   |           |
+------------------------------+   |           |
| ...                          |   |           |
+------------------------------+   |           |
|           ASPECT_n           |   |           |
| * KEY_n (password protected) |   |           |
| * GEN_n (encrypted by KEY_n) |   |           |
| * MAP_n (encrypted by KEY_n) |   |           |
|    * Address of A_n/B_0      |   |           |
|    * Address of A_n/B_1      |   |           |
|    * ...                     |   |           |
|    * Address of A_n/B_m      |   |           |
+------------------------------+ --/           |
+------------------------------+ --\           |
|           BLOCK_0            |   |           |
+------------------------------+   |           |
|           BLOCK_1            |   |           |
+------------------------------+   +-> Blocks  |
| ...                          |   |           |
+------------------------------+   |           |
|           BLOCK_m            |   |           |
+------------------------------+ --/ ----------/

From the outside, without any additional information, this file looks like a simple header information, followed by random noise, regardless of whether there is any useful data in it or not. From the header, it is possible to determine the location of each structure, but without any passwords, the content of these structures is useless.

Each aspect contains a map of blocks it uses. For example, consider this mapping:
m=10, n=4
+-------------------+ +-------------------+ +-------------------+ +-------------------+
| MAP_0             | | MAP_1             | | MAP_2             | | MAP_3             |
+-------------------+ +-------------------+ +-------------------+ +-------------------+
| A_0/B_0 = BLOCK_4 | | A_1/B_0 = BLOCK_5 | | A_2/B_0 = BLOCK_6 | | A_3/B_0 = UNUSED  |
| A_0/B_1 = BLOCK_7 | | A_1/B_1 = BLOCK_3 | | A_2/B_1 = UNUSED  | | A_3/B_1 = UNUSED  |
| A_0/B_2 = UNUSED  | | A_1/B_2 = BLOCK_9 | | A_2/B_2 = UNUSED  | | A_3/B_2 = UNUSED  |
| A_0/B_3 = UNUSED  | | A_1/B_3 = BLOCK_0 | | A_2/B_3 = UNUSED  | | A_3/B_3 = UNUSED  |
| A_0/B_4 = UNUSED  | | A_1/B_4 = UNUSED  | | A_2/B_4 = UNUSED  | | A_3/B_4 = UNUSED  |
| A_0/B_5 = UNUSED  | | A_1/B_5 = UNUSED  | | A_2/B_5 = UNUSED  | | A_3/B_5 = UNUSED  |
| A_0/B_6 = UNUSED  | | A_1/B_6 = UNUSED  | | A_2/B_6 = UNUSED  | | A_3/B_6 = UNUSED  |
| A_0/B_7 = UNUSED  | | A_1/B_7 = UNUSED  | | A_2/B_7 = UNUSED  | | A_3/B_7 = UNUSED  |
| A_0/B_8 = UNUSED  | | A_1/B_8 = UNUSED  | | A_2/B_8 = UNUSED  | | A_3/B_8 = UNUSED  |
| A_0/B_9 = UNUSED  | | A_1/B_9 = UNUSED  | | A_2/B_9 = UNUSED  | | A_3/B_9 = UNUSED  |
+-------------------+ +-------------------+ +-------------------+ +-------------------+

The actual blocks would then contain fragmented data of aspects with the following order:
+-------------------+
| BLOCK_0 = A_1/B_3 |
| BLOCK_1 = UNUSED  |
| BLOCK_2 = UNUSED  |
| BLOCK_3 = A_1/B_1 |
| BLOCK_4 = A_0/B_0 |
| BLOCK_5 = A_1/B_0 |
| BLOCK_6 = A_2/B_0 |
| BLOCK_7 = A_0/B_1 |
| BLOCK_8 = UNUSED  |
| BLOCK_9 = A_1/B_2 |
+-------------------+

Now, let's consider that the user wants to read data from aspect 1. To do this, they need to provide password for KEY_1, which decrypts GEN_1 and MAP_1. The map can be read sequentially, and blocks can be fetched as they are referenced by the map. Each block can then be decrypted using a key generated by the lattice generator GEN_1 for each block, seeded by the block number (e.g. A_1/B_0=BLOCK_5 will be decrypted using key generated by GEN_1(0), A_1/B_1=BLOCK_3 by GEN_1(1), A_1/B_2=BLOCK_9 by GEN_1(2), and A_1/B_3=BLOCK_0 by GEN_1(3)). This yields the desired plaintext.

However, the situation is more interesting when the user wants to write data. Do note that MAP_1 contains no information about which blocks are free for use by additional data. Since the unused blocks BLOCK_1, BLOCK_2, and BLOCK_8 contain random data, it is impossible to determine that no aspect is using them without decrypting maps of all aspects. Therefore, if the user only provided KEY_1, they would know only that BLOCK_5, BLOCK_3, BLOCK_9, and BLOCK_0 are used, and the rest is free, leading to potential overwrites of blocks belonging to other aspects. To prevent overwriting, the user would need to provide passwords of all aspects they want to preserve, so that their maps can also be decrypted and considered when determining which blocks are free.
Let's consider that the user wants to write 4 blocks worth of data into ASPECT_3, while only possessing passwords to KEY_1, KEY_2, and KEY_3. To do this, they provide these 3 keys to decrypt MAP_1, MAP_2, and MAP_3. By examining the maps, they see that blocks BLOCK_1, BLOCK_2, BLOCK_4, BLOCK_7, and BLOCK_8 are unused (blocks BLOCK_4 and BLOCK_7 are in fact used by ASPECT_0, but the user doesn't have password for KEY_0 required to decrypt MAP_0 which would inform them of this). The user then supplies the 4 blocks worth of data, which are allocated to 4 of the 5 available blocks on random. For example, A_3/B_0 gets allocated to BLOCK_7, A_3/B_1 to BLOCK_2, A_3/B_2 to BLOCK_1, and A_3/B_3 to BLOCK_8. This would result in the following layout:
+-------------------------------+ +-------------------+ +-------------------+ +-------------------+
| MAP_0                         | | MAP_1             | | MAP_2             | | MAP_3             |
+-------------------------------+ +-------------------+ +-------------------+ +-------------------+
| A_0/B_0 = BLOCK_4             | | A_1/B_0 = BLOCK_5 | | A_2/B_0 = BLOCK_6 | | A_3/B_0 = BLOCK_7 |
| A_0/B_1 = BLOCK_7 (corrupted) | | A_1/B_1 = BLOCK_3 | | A_2/B_1 = UNUSED  | | A_3/B_1 = BLOCK_2 |
| A_0/B_2 = UNUSED              | | A_1/B_2 = BLOCK_9 | | A_2/B_2 = UNUSED  | | A_3/B_2 = BLOCK_1 |
| A_0/B_3 = UNUSED              | | A_1/B_3 = BLOCK_0 | | A_2/B_3 = UNUSED  | | A_3/B_3 = BLOCK_8 |
| A_0/B_4 = UNUSED              | | A_1/B_4 = UNUSED  | | A_2/B_4 = UNUSED  | | A_3/B_4 = UNUSED  |
| A_0/B_5 = UNUSED              | | A_1/B_5 = UNUSED  | | A_2/B_5 = UNUSED  | | A_3/B_5 = UNUSED  |
| A_0/B_6 = UNUSED              | | A_1/B_6 = UNUSED  | | A_2/B_6 = UNUSED  | | A_3/B_6 = UNUSED  |
| A_0/B_7 = UNUSED              | | A_1/B_7 = UNUSED  | | A_2/B_7 = UNUSED  | | A_3/B_7 = UNUSED  |
| A_0/B_8 = UNUSED              | | A_1/B_8 = UNUSED  | | A_2/B_8 = UNUSED  | | A_3/B_8 = UNUSED  |
| A_0/B_9 = UNUSED              | | A_1/B_9 = UNUSED  | | A_2/B_9 = UNUSED  | | A_3/B_9 = UNUSED  |
+-------------------------------+ +-------------------+ +-------------------+ +-------------------+

+-------------------+
| BLOCK_0 = A_1/B_3 |
| BLOCK_1 = A_3/B_2 |
| BLOCK_2 = A_3/B_1 |
| BLOCK_3 = A_1/B_1 |
| BLOCK_4 = A_0/B_0 |
| BLOCK_5 = A_1/B_0 |
| BLOCK_6 = A_2/B_0 |
| BLOCK_7 = A_3/B_0 | <- Overwritten block!
| BLOCK_8 = A_3/B_3 |
| BLOCK_9 = A_1/B_2 |
+-------------------+

The blocks will then be encrypted by GEN_3 in the same way as when decrypting (e.g. A_3/B_0=BLOCK_7 will be encrypted using key generated by GEN_3(0), A_3/B_1=BLOCK_2 by GEN_3(1), A_3/B_2=BLOCK_1 by GEN_3(2), and A_3/B_3=BLOCK_8 by GEN_3(3)).


When an extent is created, the following sequence of events needs to occur:
1. The header fields are populated with user's preferences.
1.1 The number of aspects (n) defaults to 8, so that the actual number of used extents cannot be infered from the number of present extents. The user is advised to set n to a higher value than is actually needed.
2. Keys for each aspects are generated
3. The user is asked to enter unique password for individual keys, in random order
3.1 The user can enter less than n passwords, in which case the rest is generated randomly
4. Block maps of each aspect are initialised
